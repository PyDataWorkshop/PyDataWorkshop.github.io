
﻿<ul>
	<li>Generating Random Numbers – <a href="https://dl.dropboxusercontent.com/u/6044937/PyData/KSnotes/RandomNumbers.pdf" target="_blank">Notes</a></li>
</ul>


<h1>Random Number Generation with NumPy</h1>

 For the sake of brevity, the specific functions names are given in the example below, rather than the full specification.

The <tt>rand()</tt> command is fully specified as <tt>np.random.rand()</tt>


% 19.1 Simulating Random Variables
% - 19.1.1 Core Random Number Generators
NumPy random number generators are all stored in the module <tt>numpy.random</tt>. 
These can be imported with using <tt>import numpy as np</tt> and then calling <tt>np.random.rand</tt>, for example, or 
by importing <tt>import numpy.random as rnd</tt> and <tt>using rnd.rand.1</tt>.
<h4><tt>rand</tt>, <tt>random_sample</tt></h4>
<tt>rand} and <tt>random_sample }are uniform randomnumber generators whichare
 identicalexceptthat rand takes a variable number 
of integer inputs – one for each dimension – while <tt>random_sample</tt> takes a n-element tuple. 

 <tt>random_sample} is the preferred NumPy function, and <tt>rand} is a convenience function primarily for \textit{MATLAB} users.
<pre>
<code>
x = rand(3,4,5) 
y = random_sample((3,4,5))
</code>
</pre>


<br>
<h4><tt>randn, standard_normal</h4>
<ul>
<li> <tt>randn</tt> and <tt>standard_normal</tt> are standard normal (i.e. Z-value) random number generators. <tt>randn</tt>, like <tt>rand</tt>, takes a
variable number of integer inputs, and <tt>standard_normal</tt> takes an n-element tuple. 
<li> Both can be called
with no arguments to generate a single standard normal (e.g. randn()). 
<li> <tt>standard_normal</tt> is the preferred
NumPy function, and <tt>randn</tt> is a convenience function intended primarily for MATLAB users .
</ul>

<pre>
<code>
>>> x = randn(3,4,5)
>>> y = standard_normal((3,4,5))
</code>
</pre>
<br>

<h4><tt>randint, random_integers</h4>
<tt>randint</tt> and <tt>random_integers</tt> are uniform integer random number generators which take 3 inputs: low,
high and size. 
<ul>
<li> <tt>low</tt> is the lower bound of the integers generated, 
<li> <tt>high</tt> is the upper,
<li> <tt>size</tt> is a n-elementtuple. 
</ul>

<b>Important:</b><br>
 <tt>randint()</tt> and <tt>random_integers</tt> differ in that <tt>randint</tt> generates integers exclusive of the value in <tt>high</tt>
(as do most Python functions), while <tt>random_integers</tt> includes the value in <tt>high</ttt> in its range.
<pre>
<code>
x = randint(0,10,(100))
x.max() 
# Is 9 since range is [0,10)

y = random_integers(0,10,(100))
y.max() 
# Is 10 since range is [0,10]
</code>
</pre>
<h3> Random Array Functions</h3>
<br>
<h4><tt>shuffle</h4>
<tt>shuffle} randomly reorders the elements of an array in place.
<pre>
<code>
>>> x = arange(10)
>>> shuffle(x)
>>> x
array([4, 6, 3, 7, 9, 0, 2, 1, 8, 5])
</code>
</pre>


<h4><tt>permutation</h4>
<tt>permutation} returns randomly reordered elements of an array as a copy while not directly changing the
input.
<pre>
<code>
>>> x = arange(10)
>>> permutation(x)
array([2, 5, 3, 0, 6, 1, 9, 8, 4, 7])
>>> x
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code>
</pre>
<h3>Select Random Number Generators</h3>
<ul>
<li> NumPy provides a large selection of random number generators for specific distribution. 
<li> All take between
0 and 2 required inputs which are parameters of the distribution, plus a tuple containing the size of the
output. 
<li> All random number generators are in the module <tt>numpy.random}.
</ul>
<br>

<h4><tt>seed</h4>

<ul>
<li> <tt>numpy.random.seed</tt> is a more useful function for initializing the random number generator, and can be
used in one of two ways. <tt>seed()</tt> will initialize (or reinitialize) the random number generator using some
actual random data provided by the operating system.

<li> <tt>seed( s )</tt> takes a vector of values (can be scalar) to
initialize the random number generator at particular state. 
<li> <tt>seed( s )</tt> is particularly useful for producing
simulation studies which are reproducible. 
<h4>Example</h4>
In the following example, calls to <tt>seed()</tt> produce different
random numbers, since these reinitialize using random data from the computer, while calls to <tt>seed(0)</tt>
produce the same random number or sequence of random numbers.
<br>
</ul>
<pre>
	<code>
	>>> seed()
	>>> randn()
	
	array([ 0.62968838])
	>>>
	>>> seed()
	>>> randn()
	
	array([ 2.230155])
	>>> ## Different
	>>>
	>>> seed(0)
	>>> randn()
	
	array([ 1.76405235])
	>>>
	>>> seed(0)
	>>> randn()
	
	array([ 1.76405235])
	>>> #Same as last draw
	</code>
</pre>
NumPy always calls <tt>seed()</tt>  when the first random number is generated. As a result. calling <tt>standard_normal()}
across two “fresh” sessions will not produce the same random number.
<br>

% 19.1.2 Random Array Functions
%======================================================================== %
% 19.1.3 Select Random Number Generators
<h4>Select Random Number Generators</h4>
<ul>
<li> NumPy provides a large selection of random number generators for specific distribution. 

<li> All take between 0 and 2 required inputs which are parameters of the distribution, plus a tuple containing the size of the output. 
<li> All random number generators are in the module 
<tt>numpy.random}.
</ul>


<h4>Bernoulli</h4>
<ul>
<li> There is no \textbf{\textit{Bernoulli generator</h4>. 
<li> Instead use <tt>binomial(1,p)} to generate a single draw or <tt>binomial(1,p,(10,10))} to generate an array where 
<tt>p} is the probability of success.
</ul>



%=================================%

%19.2 Simulation and Random Number Generation
<h4>Simulation and Random Number Generation</h4>
<ul>
<li> Computer simulated random numbers are usually constructed from very complex but ultimately deterministic
functions. 
<li> Because they are not actually random, simulated random numbers are generally described
to as \textbf{pseudo-random}. 
<li> All pseudo-random numbers in NumPy use one core random number generator
based on the \textbf{\textit{Mersenne Twister</h4>, a generator which can produce a very long series of pseudo-random
data before repeating (up to $2^19937 - 1$ non-repeating values).
</ul>
%======================================================== %
<br>
<h4><tt>RandomState</h4>
<tt>RandomState} is the class used to control the random number generators. Multiple generators can be initialized
by <tt>RandomState}.
<pre>
	<code>
	>>> gen1 = np.random.RandomState()
	>>> gen2 = np.random.RandomState()
	>>>
	>>> # Generate a uniform
	>>> gen1.uniform() 
	
	    0.6767614077579269
	>>>
	>>> state1 = gen1.get_state()
	>>> gen1.uniform()
	
		0.6046087317893271
	>>>
	>>> # Different, since gen2 has different seed
	>>> gen2.uniform()
	
		0.04519705909244154
	>>>
	>>> # Same uniform as gen1 after assigning state
	>>> gen2.set_state(state1)
	>>> gen2.uniform() 
		
		0.6046087317893271
	</code>
</pre>
%==============%
% 19.2.1
<h4><tt> State</h4>
<ul>
<li> Pseudo-random number generators track a set of values known as the \textit{state}. 
<li> The state is usually a vector
which has the property that if two instances of the same pseudo-random number generator have the
same state, the sequence of pseudo-random numbers generated will be identical. 
<li> The state of the default
random number generator can be read using \\ <tt>numpy.random.get_state} and can be restored using
<tt>numpy.random.set_state}.
</ul>

<pre>
	<code>>>> st = get_state()
	>>> randn(4)
	
	array([ 0.37283499, 0.63661908, 1.51588209,	1.36540624])
	>>>
	>>> set_state(st)
	>>> randn(4)
	
	array([ 0.37283499, 0.63661908, 1.51588209,	1.36540624])
	</code>
</pre>
<ul>
<li> The two sequences are identical since they the state is the same when <tt>randn</tt> is called. 
<li> The state is a 5-
element tuple where the second element is a 625 by 1 vector of unsigned 32-bit integers. 
<li> In practice the
state should only be stored using <tt>get_state} and restored using <tt>set_state}.
</ul>

<br>

<h4><tt>get_state</h4>
%19.2
<ul>
<li> <tt>get_state()} gets the current state of the random number generator, which is a 5-element tuple. 
<li> It can be
called as a function, in which case it gets the state of the default random number generator, or as a method
on a particular instance of <tt>RandomState}.
</ul>

<h4><tt>set_state</h4>
%19.2.1
<ul>
<li> <tt>set_state(state)} sets the state of the random number generator. 
<li> It can be called as a function, in which
case it sets the state of the default random number generator, or as a method on a particular instance of
<tt>RandomState}.<li> <tt>set_state} should generally only be called using a state tuple returned by <tt>get_state}.
</ul>
