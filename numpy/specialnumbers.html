### *{ Special Numbers : \texttt{inf} and \texttt{NaN}}


 \texttt{inf} represents infinity and \texttt{inf} is distinct from \texttt{-inf}.
 \texttt{inf} can be constructed in a number for ways, for
example or exp(710). 

 \texttt{nan} stands for \textbf{\textit{Not a Number}}, and nans are created whenever a function produces
a result that cannot be clearly evaluated to produce a number or infinity. For example, \texttt{inf/-inf} results in
\texttt{nan}. 
 \texttt{nans} often cause problems since most mathematical operations involving a \texttt{nan }produce a \texttt{nan}.

\begin{framed}
\begin{verbatim}
>>> x = nan
>>> 1.0 + x
nan
>>> 1.0 * x
nan
>>> 0.0 * x
nan
>>> mean(x)
nan
\end{verbatim}
\end{framed}

%
%10.2 Floating point precision
%All numeric software has limited precision; Python is no different. 
%
%The easiest to understand the upper
%and lower limits, which are 1.797610308 (see finfo(float).max) and􀀀1.797610308 (finfo(float).min).
%Numbers larger (in absolute value) than these are inf. The smallest positive number that can be expressed
%is 2.225010􀀀308 (see finfo(float).tiny). Numbers between 􀀀2.225110􀀀308 and 2.225110􀀀308 are
%numerically 0.
%However, the hardest concept to understand about numerical accuracy is the limited relative precision
%which is 2.2204  10􀀀16 on most x86 and x86_64 systems. This value is returned from the command
%finfo(float).eps and may vary based on the type of CPU and/or the operating system used. Numbers
%which differ by less than 2.220410􀀀16 are numerically the same. To explore the role of precision, examine
%the results of the following:
%\begin{framed}
% \begin{verbatim}
% >>> x = 1.0
% >>> eps = finfo(float).eps
% >>> x = x+eps/2
% >>> x == 1
% True
% >>> x1
% 0.0
% >>> x = 1 + 2*eps
% >>> x == 1
% False
% >>> x1
% ans = 4.4408920985006262e16
% \end{verbatim}
%\end{framed}
%Moreover, any number y where y <
%􀀀
%x  2.2204  10􀀀16
%is treated as 0 when added or subtracted.
%This is referred to as relative range.
%\begin{framed}
% \begin{verbatim}
% >>> x=10
% >>> x+2*eps
% >>> x10
% 0
% >>> (x10)
% == 0
% True
% >>> (1e120 1e103)
% == 1e120
% True
% >>> 1e103 / 1e120
% 1e17
% \end{verbatim}
%\end{framed}
%In the first example, eps/2<eps when compared to 1 so it has no effect while 2*eps>eps and so this value
%is different from 1. In the second example, 2*eps/10<eps, it has no effect when added. The final example
%subtracts 10103 from 10120 and shows that this is numerically the same as 10120 – again, this occurs since
%10103=10120 = 10􀀀17 <eps. While numeric limits is a tricky concept to understand, failure to understand
%these limits can results in errors in code that appears to be otherwise correct. The practical usefulness of
%limited precision is to consider data scaling since many variables have natural scales which are differ by
%many orders of magnitude.
