\section{More Mathematical Functions}
% 6.3 Mathematics
% 6.2 Rounding and Precision
% 6.1 Moved to last
%=================================%

\subsection{Complex Numbers}
%---------------------------------------%
\subsubsection*{\texttt{real}}
\begin{itemize}
	\item \texttt{real} returns the real elements of a complex array. 
	\item \texttt{real} can be called either as a function \texttt{real(x)} or as an
	attribute \texttt{x.real}.
\end{itemize}
%---------------------------------------%
\subsubsection*{\texttt{imag}}
\begin{itemize}
	\item  \texttt{imag} returns the complex elements of a complex array.
	\item  \texttt{imag} can be called either as a function \texttt{imag(x)} or
	as an attribute \texttt{x.imag}.
\end{itemize}
%---------------------------------------%
\subsubsection*{\texttt{conj, conjugate}}
\begin{itemize}
	\item \texttt{conj} returns the element-by-element complex conjugate for a complex array. 
	\item \texttt{conj} can be called either as
	a function \texttt{conj(x)} or as a method \texttt{x.conj()}. 
	\item \texttt{conjugate} is identical to \texttt{conj}.
\end{itemize}
%===================================================================================== %
\newpage
\subsection{Set Functions}
%---------------------------------------%
\subsubsection*{\texttt{unique}}
\texttt{unique} returns the unique elements in an array. It only operates on the entire array. An optional second
argument can be returned which contains the original indices of the unique elements.
\begin{framed}
	\begin{verbatim}
	>>> x = repeat(randn(3),(2))
	array([ 0.11335982, 0.11335982, 0.26617443, 0.26617443,
	1.34424621, 1.34424621])
	>>>
	>>> unique(x)
	array([ 0.11335982, 0.26617443, 1.34424621])
	>>>
	>>> y,ind = unique(x, True)
	>>>
	>>> ind
	array([0, 2, 4], dtype=int64)
	>>>
	>>> x.flat[ind]
	array([ 0.11335982, 0.26617443, 1.34424621])
	\end{verbatim}
\end{framed}
\newpage
%---------------------------------------%
\subsubsection*{\texttt{in1d}}
\texttt{in1d} returns a Boolean array with the same size as the first input array indicating the elements which are
also in a second array.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(10.0)
	>>> y = arange(5.0,15.0)
	>>> in1d(x,y)
	array([False, False, False, False, False, 
	True, True, True, True, True], dtype=bool)
	\end{verbatim}
\end{framed}
%---------------------------------------%
\subsubsection*{\texttt{intersect1d}}
\texttt{intersect1d} is similar to \texttt{in1d}, except that it returns the elements rather than a Boolean array, and only
unique elements are returned. It is equivalent to \texttt{unique(x.flat[in1d(x,y)])}.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(10.0)
	>>> y = arange(5.0,15.0)
	>>> intersect1d(x,y)
	array([ 5., 6., 7., 8., 9.])
	\end{verbatim}
\end{framed}
%---------------------------------------%
\subsubsection*{\texttt{union1d}}
\texttt{union1d} returns the unique set of elements in 2 arrays.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(10.0)
	>>> y = arange(5.0,15.0)
	>>> union1d(x,y)
	array([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.,
	11., 12., 13., 14.])
	\end{verbatim}
\end{framed}
%---------------------------------------%
\subsubsection*{\texttt{setdiff1d}}
\texttt{setdiff1d} returns the set of the elements which are only in the first array but not in the second array.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(10.0)
	>>> y = arange(5.0,15.0)
	>>> setdiff1d(x,y)
	array([ 0., 1., 2., 3., 4.])
	\end{verbatim}
\end{framed}
%---------------------------------------%
\subsubsection*{\texttt{setxor1d}}
\texttt{setxor1d} returns the set of elements which are in one (and only one) of two arrays.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(10.0)
	>>> y = arange(5.0,15.0)
	>>> setxor1d(x,y)
	array([ 0., 1., 2., 3., 4., 10., 11., 12., 13., 14.])
	\end{verbatim}
\end{framed}
%=======================================================================%
\newpage
\subsection{Sorting and Extreme Values}
\subsubsection*{\texttt{sort}}
\texttt{sort} sorts the elements of an array. By default, it sorts using the last axis of x. 
\begin{framed}
	\begin{verbatim}
	>>> x = randn(4,2)
	>>> x
	array([[ 1.29185667, 0.28150618],
	       [ 0.15985346, 0.93551769],
	       [ 0.12670061, 0.6705467 ],
	       [ 2.77186969, 0.85239722]])
	>>>
	>>> sort(x)
	array([[ 0.28150618, 1.29185667],
	       [ 0.93551769, 0.15985346],
 	       [ 0.12670061, 0.6705467 ],
	       [ 0.85239722, 2.77186969]])
	
	
	\end{verbatim}
\end{framed}
\newpage
\texttt{sort} uses an optional second
argument to indicate the axis to use for sorting (i.e. 0 for column-by-column, None for sorting all elements).

\begin{framed}
	\begin{verbatim}
	>>> sort(x, 0)
	array([[ 0.12670061, 0.93551769],
	       [ 0.15985346, 0.85239722],
	       [ 1.29185667, 0.28150618],
	       [ 2.77186969, 0.6705467 ]])
	>>>
	>>> sort(x, axis=None)
	array([0.93551769, 0.85239722, 0.12670061, 0.15985346, 0.28150618,
	0.6705467 , 1.29185667, 2.77186969])
	\end{verbatim}
\end{framed}

\texttt{sort }does not alter the input when called as function, unlike the method version of \texttt{sort}.
\newpage
\subsubsection{ndarray.sort, argsort}
\begin{itemize}
	\item \texttt{ndarray.sort} is a method for ndarrays which performs an in-place sort. 
	\item It economizes on memory use,
	although \texttt{x.sort()} is different from x after the function, unlike a call to \texttt{sort(x)}. 
	\item \texttt{x.sort()} sorts along
	the last axis by default, and takes the same optional arguments as \texttt{sort(x)}.
	\item \texttt{argsort} returns the indices
	necessary to produce a sorted array, but does not actually sort the data. 
	\item It is otherwise identical to \texttt{sort},
	and can be used either as a function or a method.
\end{itemize}

\begin{framed}
	\begin{verbatim}
	>>> x = randn(3)
	>>> x
	array([ 2.70362768, 0.80380223,0.10376901])
	>>>
	>>> sort(x)
	array([0.80380223,0.10376901,2.70362768])
	>>>
	>>> x
	array([ 2.70362768, 0.80380223,0.10376901])
	>>>
	>>> x.sort() # Inplace,changes x
	>>>
	>>> x
	array([0.80380223,0.10376901,2.70362768])
	\end{verbatim}
\end{framed}
\subsubsection{\texttt{max}, \texttt{amax}, \texttt{argmax}, \texttt{min}, \texttt{amin}, \texttt{argmin}}
\texttt{max} and \texttt{min} return the maximum and minimum values from an array. They take an optional second argument
which indicates the axis to use.
\begin{framed}
	\begin{verbatim}
	>>> x = randn(3,4)
	>>> x
	array([[0.71604847,0.35276614, 0.95762144,0.48490885],
	       [0.47737217,1.57781686, 0.36853876,2.42351936], 
	       [ 0.44921571, 0.03030771,1.28081091, 0.97422539]])
	>>>
	>>> amax(x)
	2.4235193583347918
	>>>
	>>> x.max()
	2.4235193583347918
	>>>
	>>> x.max(0)
	array([ 0.44921571, 1.57781686, 1.28081091, 2.42351936])
	>>>
	>>> x.max(1)
	array([ 0.48490885, 2.42351936, 1.28081091])
	\end{verbatim}
\end{framed}
\begin{itemize}
	\item \texttt{max} and \texttt{min} can only be used on arrays as methods. 
	\item When used as a function, \texttt{amax} and \texttt{amin} must be used
	to avoid conflicts with the built-in functions \texttt{max} and \texttt{min}. 
	% \item This behavior is also seen in around and round.
	\item \texttt{argmax} and \texttt{argmin} return the \textbf{index} or indices of the maximum or minimum element(s). 
	\item They are used in
	an identical manner to \texttt{max} and \texttt{min}, and can be used either as a function or method.
\end{itemize}

\subsubsection{\texttt{minimum}, \texttt{maximum}}
\texttt{maximum} and \texttt{minimum} can be used to compute the maximum and minimum of two arrays which are broadcastable.
\begin{framed}
	\begin{verbatim}
	>>> x = randn(4)
	>>> x
	array([0.00672734, 0.16735647, 0.00154181, 0.98676201])
	>>>
	>>> y = randn(4)
	array([0.69137963, 2.03640622, 0.71255975, 0.60003157])
	>>>
	>>> maximum(x,y)
	array([0.00672734,0.16735647, 0.71255975, 0.60003157])
	\end{verbatim}
\end{framed}
%=======================================================================%
\newpage
\subsection{Nan Functions}
NaN function are convenience function which act similarly to their non-NaN versions, only ignoring NaN
values (rather than propagating) when computing the function.
\subsection{nansum}
\begin{itemize}
	\item \texttt{nansum} is identical to sum, except that NaNs are ignored.
	\item \texttt{nansum} can be used to easily generate other NaNfunctions,
	such as \texttt{nanstd} (standard deviation, ignoring nans) since variance can be implemented using 2
	sums.
\end{itemize}

\begin{framed}
	\begin{verbatim}
	>>> x = randn(4)
	>>> x[1] = nan
	>>> x
	array([0.00672734,nan, 0.00154181, 0.98676201])
	>>>
	>>> sum(x)
	nan
	>>> 
	>>> nansum(x)
	0.99194753275859726
	>>>
	>>> nansum(x) / sum(x[logical_not(isnan(x))])
	1.0
	>>> nansum(x) / sum(1-isnan(x)) # nanmean
	0.33064917999999999
	\end{verbatim}
\end{framed}
\subsection{nanmax, nanargmax, nanmin, nanargmin}

\texttt{nanmax}, \texttt{nanmin, nanargmax} and \texttt{nanargmin} are identical to their non-NaN counterparts, except that NaNs
are ignored.
\newpage
\subsection{Functions and Methods/Properties}
Many operations on NumPy arrays and matrices can be performed using a function or as a method of the
array. For example, consider \texttt{reshape}.
\begin{framed}
	\begin{verbatim}
	>>> x = arange(25.0)
	>>> y = x.reshape((5,5))
	>>> y
	array([[ 0., 1., 2., 3., 4.],
	       [ 5., 6., 7., 8., 9.],
	       [ 10., 11., 12., 13., 14.],
	       [ 15., 16., 17., 18., 19.], 
	       [ 20., 21., 22., 23., 24.]])
	
	>>>
	>>> z = reshape(x,(5,5))
	>>> z
	array([[ 0., 1., 2., 3., 4.],
	       [ 5., 6., 7., 8., 9.],
	       [ 10., 11., 12., 13., 14.],
	       [ 15., 16., 17., 18., 19.],
	       [ 20., 21., 22., 23., 24.]])
	\end{verbatim}
\end{framed}
%Both the function and method produce the same output and the choice of which to use is ultimately a
%personal decision. I use both and the choice primarily depends on the context. For example, to get the
%shape of an array, my preference is for x.shape over shape(x) since shape appears to be integral to x.1 On
%the other hand, I prefer shape(y+z) over (y+z).shape due to the presence of the mathematical operation.
%1Formally shape is a property of an array, not a method since it does not require a function call.
%

\end{document}
