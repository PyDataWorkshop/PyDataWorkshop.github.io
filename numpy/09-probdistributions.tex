\documentclass[MASTER.tex]{subfiles} 

 

\section{Probability Distributions}

 
 The Normal Distribution  - <tt>{normal}}
  
 \textbf{The main commands}
  
  <tt>{normal()} generates a set of random numbers from a standard Normal distribution.*  <tt>{normal(mu, sigma)} generates draws from
 a Normal distribution with mean $\mu$ and standard deviation $\sigma$.  <tt>{normal(mu, sigma, (10,10))} generates a 10 by 10 array
 of draws from a Normal with mean $\mu$ and standard deviation $\sigma$. 
  
 <tt>{normal(mu, sigma)} is equivalent to <tt>{mu + sigma $\ast$ <tt>{standard\_normal()}}.
  
 

 
 The Poisson Distribution - <tt>{poisson}}
  
  <tt>{poisson()} generates a set of random numbers from a Poisson distribution with $\lambda = 1$.*   <tt>{poisson(lambda)} generates a draw
  from a Poisson distribution with expectation $\lambda$. 
   poisson(lambda, (10,10)) generates a 10 by 10 array of
  draws from a Poisson distribution with expectation $\lambda$.
  
  

 

 
 <tt>{standard\_t}}
 <tt>{standard\_t(nu)} generates a set of random numbers from a Student’s t with shape parameter $\nu$.\\ <tt>{standard\_t(nu, (10,10))}
 generates a 10 by 10 array of draws from a Student’s t with shape parameter $\nu$.
 

 
 <tt>{uniform}}
 <tt>{uniform()} generates a uniform random variable on (0, 1). \\ <tt>{uniform(low, high)} generates a uniform on
 (l , h). <tt>{uniform(low, high, (10,10))} generates a 10 by 10 array of uniforms on (l , h).
 
 

 
 Continuous Random Variables}
 
 SciPy contains a large number of functions for working with continuous random variables. Each function
 resides in its own class (e.g. norm for Normal or gamma for Gamma), and classes expose methods for random
 number generation, computing the PDF, CDF and inverse CDF, fitting parameters using MLE, and
 computing various moments. The methods are listed below, where dist is a generic placeholder for the
 distribution name in SciPy. 
 

 
   
   <tt>{dist.rvs}\\
  Pseudo-randomnumbergeneration. Generically, rvs is called using dist.rvs(*args, loc=0, scale=1, size=size)
  where size is an n-element tuple containing the size of the array to be generated.
   <tt>{dist.pdf}\\
  Probability density function evaluation for an array of data (element-by-element). Generically, pdf is
  called using <tt>{dist.pdf(x, *args, loc=0, scale=1)} where x is an array that contains the values to use when
  evaluating PDF.
%   <tt>{dist.logpdf}\\
%  Log probability density function evaluation for an array of data (element-by-element). Generically, logpdf
%  is called using dist.logpdf(x, *args, loc=0, scale=1) where x is an array that contains the values to use
%  when evaluating log PDF.
  
 

 
  
   <tt>{dist.cdf}\\
  Cumulative distribution function evaluation for an array of data (element-by-element). Generically, cdf
  is called using d<tt>{ist.cdf(x, *args, loc=0, scale=1)} where x is an array that contains the values to use
  when evaluating CDF.
   <tt>{dist.ppf}\\
  Inverse CDF evaluation (also known as percent point function) for an array of values between 0 and 1.
  Generically, ppf is called using <tt>{dist.ppf(p, *args, loc=0, scale=1)} where p is an array with all elements
  between 0 and 1 that contains the values to use when evaluating inverse CDF.
  
 

 
  
   <tt>{dist.fit}\\
  Estimate shape, location, and scale parameters from data by maximum likelihood using an array of data.
  \\ Generically, fit is called using <tt>{dist.fit(data, *args, floc=0, fscale=1)} where data is a data array used
  to estimate the parameters. \\ floc forces the location to a particular value (e.g. floc=0). <tt>{fscale} similarly
  forces the scale to a particular value (e.g. <tt>{fscale=1}) .\\  It is necessary to use floc and/or fscale when
  computing MLEs if the distribution does not have a location and/or scale.\\ For example, the gamma distribution
  is defined using 2 parameters, often referred to as shape and scale. \\ In order to useMLto estimate
  parameters from a gamma, floc=0 must be used.
  
 

 
  
   <tt>{dist.median}\\
  Returns the median of the distribution. Generically, median is called using dist.median(*args, loc=0, scale=1).
   <tt>{dist.mean}\\
  Returns the mean of the distribution. Generically, mean is called using dist.mean(*args, loc=0, scale=1).
  <tt>{ dist.moment}\\
  nth non-centralmomentevaluation of the distribution. Generically, moment is called using dist.moment(r, *args,
  loc=0, scale=1) where r is the order of the moment to compute.
   <tt>{dist.var}\\
  Returns the variance of the distribution. Generically, var is called using <tt>{dist.var(*args, loc=0, scale=1)}.
   <tt>{dist.std}\\
  Returns the standard deviation of the distribution. Generically, std is called using dist.std(*args, loc=0, scale=1).
  
 

 [fragile]
 Example}
 The gamma distribution is used as an example. \\ The gamma distribution takes 1 shape parameter a (a is
 the only element of *args), which is set to 2 in all examples.
 
  
   
  >>> import scipy.stats as stats
  >>> gamma = stats.gamma
  
  >>> gamma.mean(2), gamma.median(2)
  >>> gamma.std(2), gamma.var(2)
  (2.0, 1.6783469900166608, 1.4142135623730951, 2.0)
  
  >>> gamma.moment(2,2) gamma.
  moment(1,2)**2 # Variance
  
 ```
 

 [fragile] 
 
  
  >>> gamma.cdf(5, 2), gamma.pdf(5, 2)
  (0.95957231800548726, 0.033689734995427337)
  
  >>> gamma.ppf(.95957231800548726, 2)
  5.0000000000000018
  
  >>> log(gamma.pdf(5, 2)) gamma.
  logpdf(5, 2)
  0.0
  
 ```
 

 [fragile] 
 
  
  >>> gamma.rvs(2, size=(2,2))
  array([[ 1.83072394, 2.61422551],
         [ 1.31966169, 2.34600179]])
  
  >>> gamma.fit(gamma.rvs(2, size=(1000)), floc = 0) 
      # a, 0, shape
  (2.209958533078413, 0, 0.89187262845460313)
  
 ```
 
%      ====%
\end{document}

